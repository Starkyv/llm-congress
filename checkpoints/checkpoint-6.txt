Now create me a UI to handle this 
I will enter a topic, the debate should start

The opposition component will be in the middle, around it will be the proposition components. Each will talk and stream the text using Streamdown as a workcloud near each component. When voting each will change their color, indicating in or out. After voting the current proposition will go and the next proposition will come to middle. Refer the image for layout.

Create individual components and keep the styles in a clean styles.module.scss file for each component. Avoid inline styling to max and also avoid using tailwind. Componentize components as much as possible.

Handle all stream events. 
The stream sends:
event: agent_message_complete
data: {"agent_name": "Analyst", "content": "..."}

event: vote_cast
data: {"voter_name": "Observer", "vote": "in"}


Adapted Parser for SSE
interface SSEEvent {
  event: string;
  data: any;
}

async function streamDebate(
  topic: string,
  duration: number,
  onEvent: (event: SSEEvent) => void,
  onComplete: () => void
) {
  const response = await fetch(
    `/debate/stream?topic=${encodeURIComponent(topic)}&duration=${duration}`
  );

  if (!response.body) {
    throw new Error("No response body");
  }

  const reader = response.body.getReader();
  const decoder = new TextDecoder();
  let buffer = "";

  const processStream = async (): Promise<void> => {
    const { done, value } = await reader.read();

    if (done) {
      // Parse any remaining data in buffer
      parseSSEBuffer(buffer, onEvent);
      onComplete();
      return;
    }

    // Accumulate decoded chunks
    buffer += decoder.decode(value, { stream: true });

    // Parse complete SSE events from buffer
    buffer = parseSSEBuffer(buffer, onEvent);

    await processStream();
  };

  await processStream();
}

function parseSSEBuffer(buffer: string, onEvent: (event: SSEEvent) => void): string {
  // SSE events are separated by double newlines
  const events = buffer.split("\n\n");
  
  // Last element might be incomplete, keep it in buffer
  const remaining = events.pop() || "";

  for (const eventBlock of events) {
    if (!eventBlock.trim()) continue;

    const parsed = parseSSEEvent(eventBlock);
    if (parsed) {
      onEvent(parsed);
    }
  }

  return remaining;
}

function parseSSEEvent(eventBlock: string): SSEEvent | null {
  const lines = eventBlock.split("\n");
  let eventType = "message";
  let data = "";

  for (const line of lines) {
    if (line.startsWith("event:")) {
      eventType = line.slice(6).trim();
    } else if (line.startsWith("data:")) {
      data = line.slice(5).trim();
    } else if (line.startsWith(":")) {
      // Comment/heartbeat, ignore
      continue;
    }
  }

  if (!data) return null;

  try {
    return {
      event: eventType,
      data: JSON.parse(data),
    };
  } catch {
    return {
      event: eventType,
      data: data, // Return as string if not JSON
    };
  }
}