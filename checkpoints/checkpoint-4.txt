CHECKPOINT 4: Debate State Management Using Agno Workflow State
Goal
Use Agno's Workflow State system to manage all debate data (history, votes, timing, agent tracking) throughout the debate lifecycle. This replaces the custom state manager we were going to build.

Why Agno Workflow State is Perfect for This
Looking at Agno's State documentation, it provides exactly what you need:
✅ Persistent state across workflow steps
✅ Type-safe data structures (using Pydantic models)
✅ Automatic state management (no manual passing between steps)
✅ State validation (ensures data integrity)
✅ Easy access from any workflow step
This is much better than building custom state management!

What You're Building
Main State Model: DebateState
This is your central Pydantic model that holds ALL debate information.
State Categories:
1. Configuration State (set once at start)

Topic (string)
Duration (int - seconds)
Exchanges per round (int - how many turns before voting)

2. Agent State (tracks active agents)

Active proposition agent ID (string)
Opposition agent ID (string)
Observer agent IDs (list of strings)
All available proposition agent IDs (list)

3. Debate History State (grows during debate)

Messages (list of Message objects)

Each message has: agent_id, agent_name, role, content, timestamp, round_number


Current round number (int)
Current exchange count (int)

4. Voting State (resets each voting round)

Current votes (list of Vote objects)

Each vote has: voter_id, vote ("in"/"out"), reasoning, timestamp


Vote tally (dict: {"in": count, "out": count})
Agent being evaluated (string)

5. Switch History State (tracks changes)

Agent switches (list of Switch objects)

Each switch has: old_agent_id, new_agent_id, reason, round_number, timestamp



6. Timer State (tracks time)

Start time (datetime)
Elapsed time (int - seconds)
Paused time (int - seconds paused during voting)
Is paused (bool)

7. Phase State (tracks where we are)

Current phase (enum: "initializing", "debating", "voting", "concluding", "completed")
Status (enum: "running", "paused", "completed", "error")


State Models (Pydantic Schemas)
You need to define several Pydantic models:
Model 1: Message
Fields:
- agent_id: str
- agent_name: str
- role: str ("proposition" or "opposition")
- content: str
- timestamp: datetime
- round_number: int
- word_count: int (optional, calculated)
Model 2: Vote
Fields:
- voter_id: str
- voter_name: str
- evaluating_agent_id: str
- vote: Literal["in", "out"]
- reasoning: str
- timestamp: datetime
- round_number: int
Model 3: AgentSwitch
Fields:
- old_agent_id: str
- old_agent_name: str
- new_agent_id: str
- new_agent_name: str
- reason: str
- vote_tally: dict (the votes that caused switch)
- round_number: int
- timestamp: datetime
Model 4: DebateState (Main State)
Fields:
- Configuration:
  - topic: str
  - duration: int
  - exchanges_per_round: int

- Agent Tracking:
  - active_proposition_id: str
  - opposition_id: str
  - observer_ids: List[str]
  - all_proposition_ids: List[str]

- History:
  - messages: List[Message]
  - current_round: int
  - current_exchange: int

- Voting:
  - current_votes: List[Vote]
  - vote_tally: Dict[str, int]
  - evaluating_agent_id: Optional[str]

- Switches:
  - agent_switches: List[AgentSwitch]

- Timing:
  - start_time: datetime
  - elapsed_seconds: int
  - paused_seconds: int
  - is_paused: bool

- Phase:
  - phase: Literal["initializing", "debating", "voting", "concluding", "completed"]
  - status: Literal["running", "paused", "completed", "error"]
  - error_message: Optional[str]

State Operations (Helper Functions)
Since Agno manages state automatically, you need helper functions to modify state safely:
Operation 1: Initialize State
Purpose: Set up initial state when debate starts

Inputs:
- Topic
- Duration
- Exchanges per round
- List of all proposition agent IDs
- Opposition agent ID
- First active proposition agent ID

Actions:
- Create DebateState with initial values
- Set phase to "initializing"
- Set status to "running"
- Record start time
- Return initialized state
Operation 2: Add Message
Purpose: Record a new debate message

Inputs:
- Current state
- Agent ID
- Agent name
- Role
- Content
- Timestamp

Actions:
- Create Message object
- Append to state.messages
- Increment state.current_exchange
- Return updated state
Operation 3: Start Voting Round
Purpose: Prepare state for voting phase

Inputs:
- Current state
- Agent ID being evaluated

Actions:
- Set phase to "voting"
- Set evaluating_agent_id
- Clear current_votes list
- Reset vote_tally to {in: 0, out: 0}
- Set is_paused to True (pause timer)
- Return updated state
Operation 4: Add Vote
Purpose: Record a single vote

Inputs:
- Current state
- Voter ID
- Voter name
- Vote ("in" or "out")
- Reasoning

Actions:
- Create Vote object
- Append to state.current_votes
- Update vote_tally (increment in or out)
- Return updated state
Operation 5: Complete Voting Round
Purpose: Finalize voting and decide outcome

Inputs:
- Current state

Actions:
- Calculate if majority voted out (out > in)
- If voted out: prepare for agent switch
- Set is_paused to False (resume timer)
- Set phase back to "debating"
- Reset current_exchange to 0 (new round)
- Increment current_round
- Return updated state and decision ("switch" or "stay")
Operation 6: Record Agent Switch
Purpose: Log an agent switch

Inputs:
- Current state
- Old agent ID
- New agent ID
- Reason
- Vote tally

Actions:
- Create AgentSwitch object
- Append to state.agent_switches
- Update active_proposition_id to new agent
- Update observer_ids (old agent becomes observer, new agent becomes active)
- Return updated state
Operation 7: Update Timer
Purpose: Track elapsed time

Inputs:
- Current state

Actions:
- Calculate elapsed = (now - start_time) - paused_seconds
- Update state.elapsed_seconds
- Return updated state
Operation 8: Get Recent History
Purpose: Extract last N messages for context

Inputs:
- Current state
- Number of messages (N)

Actions:
- Get last N items from state.messages
- Format them nicely
- Return formatted context string
Operation 9: Set Phase
Purpose: Transition to new phase

Inputs:
- Current state
- New phase

Actions:
- Validate transition is valid
- Update state.phase
- Log phase change
- Return updated state
Operation 10: Get Statistics
Purpose: Calculate debate statistics

Inputs:
- Current state

Actions:
- Count messages per agent
- Calculate vote tallies per agent
- Count total switches
- Measure average message length
- Return statistics dict

Integration with Agno Workflows
How Agno State Works in Your Workflow:
Step 1: Define State Model

Create DebateState Pydantic model with all fields

Step 2: Initialize in Workflow

When workflow starts, create initial DebateState
Agno passes this state through all workflow steps automatically

Step 3: Access State in Workflow Steps

Each workflow step receives current state
Step can read from state
Step can update state
Agno handles persistence automatically

Step 4: State Flows Through Workflow
Initialize Step → state with empty messages
    ↓
Debate Step → state + new messages
    ↓
Voting Step → state + votes
    ↓
Switch Step → state + switch record
    ↓
Loop continues with updated state
    ↓
Conclusion Step → state with full history

File Structure
backend/
├── state/
│   ├── __init__.py
│   ├── models.py                # Pydantic models (Message, Vote, AgentSwitch, DebateState)
│   ├── operations.py            # State operation functions
│   └── validators.py            # Custom validation logic
├── utils/
│   ├── state_helpers.py         # Helper functions for common state operations
│   └── state_queries.py         # Functions to query state (get recent history, etc.)
└── tests/
    ├── test_state_models.py     # Test Pydantic models
    └── test_state_operations.py # Test state operations

Testing Strategy
Test 1: State Model Validation
Setup:

Try creating DebateState with valid data
Try creating with invalid data (missing fields, wrong types)

Verify:

Valid data creates state successfully
Invalid data raises validation errors
All fields have correct types

Test 2: Initialize State
Setup:

Call initialize state operation with debate parameters

Verify:

State created with correct initial values
All lists are empty
Phase is "initializing"
Timer started

Test 3: Add Messages
Setup:

Create initial state
Add 5 messages using add_message operation

Verify:

State.messages has 5 items
Exchange count incremented correctly
Messages have all required fields

Test 4: Voting Flow
Setup:

Create state with some messages
Start voting round
Add 4 votes (2 in, 2 out)
Complete voting round

Verify:

Phase changes correctly (debating → voting → debating)
Votes recorded properly
Tally calculated correctly
Timer paused during voting

Test 5: Agent Switch
Setup:

Create state
Record an agent switch

Verify:

Switch recorded in history
Active agent ID updated
Observers list updated

Test 6: Get Recent History
Setup:

Create state with 10 messages
Get last 3 messages

Verify:

Returns exactly 3 messages
Returns most recent ones
Formatted correctly

Test 7: Statistics
Setup:

Create state with full debate history
Calculate statistics

Verify:

Counts are accurate
All metrics present
No calculation errors

Test 8: State Persistence (Agno feature)
Setup:

Create workflow with state
Modify state in one step
Access state in next step

Verify:

State changes persist across steps
No data loss
State updates are atomic


What You're NOT Building
❌ Custom state persistence - Agno handles this
❌ State serialization - Pydantic handles this
❌ State passing logic - Agno workflow handles this
❌ Transaction management - Agno handles this
✅ What you ARE building:

State structure (Pydantic models)
State operations (helper functions)
State validation logic
State query functions


Benefits of Using Agno State
1. Type Safety
Pydantic ensures all data is correctly typed and validated
2. Automatic Persistence
State automatically flows through workflow steps
3. No Manual Passing
Don't need to pass state as parameter everywhere
4. Clear Structure
Single source of truth for all debate data
5. Easy Testing
Can test state operations independently
6. Debugging
Can inspect state at any workflow step
7. Serialization
State can be easily saved/loaded (for replay, analysis)

Integration Points
With Tools (Checkpoint 3):
Tools receive state as input:
- Context Builder Tool gets state.messages
- Statistics Tool gets entire state
- Vote Formatter updates state.current_votes
With Workflow (Checkpoint 6):
Workflow steps access state:
- Debate step reads state.messages, updates with new message
- Voting step reads state for evaluation, updates with votes
- Switch step reads vote tally, updates active agent
With Streaming (Checkpoint 5):
State changes trigger events:
- New message added → emit message event
- Vote added → emit vote event
- Agent switched → emit switch event

Success Criteria
✅ State models defined:

DebateState Pydantic model with all fields
Message, Vote, AgentSwitch sub-models
All models validate correctly

✅ State operations work:

Can initialize state
Can add messages
Can handle voting flow
Can record switches
Can update timer
Can query history

✅ State integrates with Agno:

Works in Agno workflows
Persists across workflow steps
No conflicts with Agno's state system

✅ All operations tested:

Each operation has unit tests
Edge cases handled
Validation works

✅ Documentation:

State structure documented
Each operation explained
Usage examples provided